# Content
- [Variables](#variables)
- [Basic Instructions](#basic-instructions)
- [Control Instructions](#control-instructions)
- [Using Stack](#using-stack)
- [System Calls](#system-calls)
    - [Linux Syscalls](#linux-syscalls) 
- [Procedures](#procedures)
- [Functions](#functions)


# Variables 

### Data Section 
- `.data` section is used to declare and initialize data variables. 
- This section is typically reserved for static data that the program will use during its execution.
```nasm
section .data
    message db "hello world", 0x0a ; declare variable called message and value hello world
    length equ $-message           ; declare variable called length and value the length of message
```

.data section is used to declare and initialize data variables. This section is typically reserved for static data that the program will use during its execution.


### BSS(Block Started by Symbol) Section
- BSS section is used to declare uninitialized data.
- This section is commonly used for declaring variables that don't need an initial value because they will be initialized at runtime or through other means.
- The BSS section is zero-initialized by the operating system when the program is loaded into memory.
```nasm
section .bss
    userInput resb 1
```



# Basic Instructions

## Data Movement

| Instruction | Description                                  | Example                      |
|-------------|----------------------------------------------|------------------------------|
| mov         | Move data or load immediate data             | `mov rax, 1` -> `rax = 1`   |
| lea         | Load an address pointing to the value        | `lea rax, [rsp+5]` -> `rax = rsp+5` |
| xchg        | Swap data between two registers or addresses | `xchg rax, rbx` -> `rax = rbx, rbx = rax` |

Note: In assembly, moving data does not affect the source operand. So, we can consider mov as a copy function, rather than an actual move.


### Moving Data

```nasm
global  _start

section .text
_start:
    mov rax, 0  ; mov 0 to rax register
    mov rbx, 1  ; mov 1 to rax register
```

### Moving Pointer Values
```nasm
global  _start

section .text
_start:
    mov rax, rsp    ; mov rsp pointer as value to rax  
    mov rax, [rsp]  ; mov rsp pointer value to rax

```

### Loading Value Pointers
```nasm
global  _start

section .text
_start:
    lea rax, [rsp+10]   ; load rsp pointer as the pointer to rax
    mov rax, [rsp+10]   ; load rsp pointer value as the value to rax

```

### Swap data

```nasm
global _start

section .text
_start:
    mov rax, 1024
    mov rbx, 2048
    xchg rax, rbx ; swap values between rax and rbx
```

## Arithmetic Instructions

### Unary Instructions

| Instruction | Description            | Example                    |
|-------------|------------------------|----------------------------|
| `inc`       | Increment by 1         | `inc rax` -> `rax++` or `rax += 1` -> `rax = 2` |
| `dec`       | Decrement by 1         | `dec rax` -> `rax--` or `rax -= 1` -> `rax = 0` |



### Binary Instructions

| Instruction | Description                    | Example                         |
|-------------|--------------------------------|---------------------------------|
| `add`       | Add both operands              | `add rax, rbx` -> `rax = 1 + 1` -> `2` |
| `sub`       | Subtract Source from Destination | `sub rax, rbx` -> `rax = 1 - 1` -> `0` |
| `imul`      | Multiply both operands          | `imul rax, rbx` -> `rax = 1 * 1` -> `1` |


### Bitwise Instructions

| Instruction | Description                                       | Example                                         |
|-------------|---------------------------------------------------|-------------------------------------------------|
| `not`       | Bitwise NOT (invert all bits)                     | `not rax` -> NOT `00000001` -> `11111110`       |
| `and`       | Bitwise AND (if both bits are 1 -> 1)             | `and rax, rbx` -> `00000001 AND 00000010` -> `00000000` |
| `or`        | Bitwise OR (if either bit is 1 -> 1)             | `or rax, rbx` -> `00000001 OR 00000010` -> `00000011` |
| `xor`       | Bitwise XOR (if bits are the same -> 0)          | `xor rax, rbx` -> `00000001 XOR 00000010` -> `00000011` |


# Control Instructions

## Loops
- loops use the register defined before it as a counter (usually `rcx` used as a loop counter )

```nasm
global _start

section .text
_start:
    mov al , 1
    mov cl , 10 

loopT :
    inc al 
    loop loopT

```

## Unconditional Branching (jumb)

| Instruction | Description                                     | Example         |
|-------------|-------------------------------------------------|-----------------|
| jmp         | Jumps to specified label, address, or location | `jmp loop`      |


```nasm
global  _start

section .text
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
    mov rcx, 10
loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    jmp loopFib
```


## Condtional Instructions

in assembly `The RFLAGS register` is used to compare in condtions and contains this flag:


| Bit(s) | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12-13 | 14  | 15  | 16  | 17  | 18  | 19  | 20  | 21  | 22-63 |
|--------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-------|-----|-----|-----|-----|-----|-----|-----|-----|-------|
| Label (1/0)  | CF  | 1   | PF  | 0   | AF  | 0   | ZF  | SF  | TF  | IF  | DF  | OF  | IOPL  | NT  | 0   | RF  | VM  | AC  | VIF | VIP | ID  | 0     |
| Desc   | Carry Flag (CY/NC) | Reserved | Parity Flag (PE/PO) | Reserved | Auxiliary Carry Flag (AC/NA) | Reserved | Zero Flag (ZR/NZ) | Sign Flag (NC/PL) | Trap Flag | Interrupt Flag (EL/DI) | Direction Flag (DN/UP) | Overflow Flag (OV/NV) | I/O Privilege Level | Nested Task | Reserved | Resume Flag | Virtual-x86 Mode | Alignment Check / Access Control | Virtual Interrupt Flag | Virtual Interrupt Pending | Identification Flag | Reserved |


`The RFLAGS register` state change every instruction happen
```nasm
global _start

section .text
_start:
    mov rbx, 0
    mov rcx, 1
    inc rbx ; here RFLAGS will have not zero 
    dec rcx ; here RFLAGS will have equal zero 
```


**we can use cmp while compare**

| Instruction | Description                                              | Example              |
|-------------|----------------------------------------------------------|----------------------|
| cmp         | Sets RFLAGS by subtracting second operand from first operand (i.e. first - second) | `cmp rax, rbx` -> `rax - rbx` |


**Conditional move**

| Instruction | Condition | Description                                |
|-------------|-----------|--------------------------------------------|
| `movee`     | ZF = 1    | Move if Equal (Zero Flag set)               |
| `movne`     | ZF = 0    | Move if Not Equal (Zero Flag clear)         |
| `movs`      | SF = 1    | Move if Negative (Sign Flag set)            |
| `movns`     | SF = 0    | Move if Not Negative (Sign Flag clear)     |
| `movg`      | SF = OF   | Move if Greater (Signed comparison)         |
| `movge`     | SF = OF or ZF = 1 | Move if Greater or Equal (Signed comparison) |
| `movl`      | SF ≠ OF   | Move if Less (Signed comparison)            |
| `movle`     | SF ≠ OF or ZF = 1 | Move if Less or Equal (Signed comparison) |

**Conditional set**

| Instruction | Condition | Description                                |
|-------------|-----------|--------------------------------------------|
| `sete`      | ZF = 1    | Set if Equal (Zero Flag set)               |
| `setne`     | ZF = 0    | Set if Not Equal (Zero Flag clear)         |
| `sets`      | SF = 1    | Set if Negative (Sign Flag set)            |
| `setns`     | SF = 0    | Set if Not Negative (Sign Flag clear)     |
| `setg`      | SF = OF   | Set if Greater (Signed comparison)         |
| `setge`     | SF = OF or ZF = 1 | Set if Greater or Equal (Signed comparison) |
| `setl`      | SF ≠ OF   | Set if Less (Signed comparison)            |
| `setle`     | SF ≠ OF or ZF = 1 | Set if Less or Equal (Signed comparison) |


**Conditional Branching(jumb)**

| Instruction | Condition | Description                             |
|-------------|-----------|-----------------------------------------|
| `jz`        | D = 0     | Destination equal to Zero               |
| `jnz`       | D != 0    | Destination Not equal to Zero           |
| `js`        | D < 0     | Destination is Negative                |
| `jns`       | D >= 0    | Destination is Not Negative (0 or positive) |
| `jg`        | D > S     | Destination Greater than Source         |
| `jge`       | D >= S    | Destination Greater than or Equal Source|
| `jl`        | D < S     | Destination Less than Source            |
| `jle`       | D <= S    | Destination Less than or Equal Source   |


# Using Stack
- The stack is a segment of memory allocated for the program to store data in, and it is usually used to store data and then retrieve them back temporarily.
- The top of the stack is referred to by the Top Stack Pointer `rsp`, while the bottom is referred to by the Base Stack Pointer `rbp`.
- The stack has a Last-in First-out (LIFO) design

| Instruction | Description                                                | Example     |
|-------------|------------------------------------------------------------|-------------|
| push        | Copies the specified register/address to the top of the stack | `push rax`  |
| pop         | Moves the item at the top of the stack to the specified register/address | `pop rax`   |

```nasm
global  _start

section .text
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
    push rax        ; push registers to stack
    push rbx
    ; call function
    pop rbx         ; restore registers from stack
    pop rax
```

# System Calls
## Linux Syscalls

- get syscalls and their number
```bash
cat /usr/include/x86_64-linux-gnu/asm/unistd_64.h
```
- get manual for syscall (arguments and their number and type) 
```sh
man -s 2 read #  check manual for read syscall
```

### Syscall Arguments

| Description                  | 64-bit Register | 8-bit Register |
|--------------------------|------------------|-----------------|
| Syscall Number/Return value | rax              | al              |
| Callee Saved               | rbx              | bl              |
| 1st arg                    | rdi              | dil             |
| 2nd arg                    | rsi              | sil             |
| 3rd arg                    | rdx              | cl              |
| 4th arg                    | rcx              | bpl             |
| 5th arg                    | r8               | r8b             |
| 6th arg                    | r9               | r9b             |

### example
program tp print message

```nasm
global  _start

section .data
    message db "hello world", 0x0a
    length equ $-message


section .text
_start:
    mov rax, 1       ; rax: syscall number 1
    mov rdi, 1       ; rdi: fd 1 for stdout
    mov rsi,message  ; rsi: pointer to message
    mov rdx,length   ; rdx: pointer to length
    syscall          ; call write syscall to the intro message
    mov rax, 60
    mov rdi, 0
    syscall
```

# Procedures
A procedure (sometimes referred to as a subroutine) is usually a set of instructions we want to execute at specific points in the program.


EX: 
```nasm
section .text
global _start

section .data
    message db "Procedure called", 0x0a
    length equ $-message

section .text
_start:
    call Procedure   ; Call the Procedure
    call Exit

Procedure:
    mov rax,1 
    mov rdi, 1      
    mov rsi,message  
    mov rdx,length   
    syscall         

Exit:
    mov rax, 60
    xor rdi, rdi
    syscall
```
# Functions

## Using External Functions

### 1) Dynamic Linker
```bash
nasm -f elf64 script.s &&  ld script.o -o script -lc --dynamic-linker /lib64/ld-linux-x86-64.so.2 && ./script
```
or assembler script
```bash
#!/bin/bash

fileName="${1%%.*}" # remove .s extension

nasm -f elf64 ${fileName}".s"
ld ${fileName}".o" -o ${fileName} -lc --dynamic-linker /lib64/ld-linux-x86-64.so.2
[ "$2" == "-g" ] && gdb -q ${fileName} || ./${fileName}
```
### 2) Include External Functions
C library `libc` is often used to make syscalls insetad of writing every thing from scratch 
```nasm
global  _start
extern  printf
```
### 3) Get Function Arguments
```bash
man -s 3 printf
```

## Writing Functions
### 1) Saving Callee Saved registers (rbx and rbp) and restore them
```nasm
printFib:
    push rax        ; push registers to stack
    push rbx
    ; function call
    pop rbx         ; restore registers from stack
    pop rax
    ret
```
### 2) Get arguments from registers
```nasm
global  _start
extern  printf

section .data
    message db "our message", 0x0a
    outFormat db  "%d", 0x0a, 0x00
......
......
printFib:
    push rax            ; push registers to stack
    push rbx
    mov rdi, outFormat  ; set 1st argument (Print Format)
    mov rsi, rbx        ; set 2nd argument (message)
    pop rbx             ; restore registers from stack
    pop rax
    ret
```
### 3) Align the Stack
1. Each procedure call adds an 8-byte address to the stack, which is then removed with ret
2. Each push adds 8-bytes to the stack as well

in this case for example 
![Screenshot_118](https://github.com/kiro6/Binary-Exploitation-Notes/assets/57776872/12d70994-6220-4819-8681-71cbfdc356da)

the stack is not alligned (we want the part in the red square to be Zeros) so we can subtracts 16 bytes from the stack pointer 

```
sub rsp, 16
call function
add rsp, 16
```

